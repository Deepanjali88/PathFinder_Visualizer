{"ast":null,"code":"export function bfs(grid, startnode, finishnode) {\n  const visitedNodesInOrder = [];\n  const queue = [];\n  queue.push(startnode);\n  console.log(\"inside the bfs function\");\n  while (queue.length !== 0) {\n    const currentnode = queue.shift();\n    if (currentnode.wall) continue;\n    if (currentnode.isVisited === true) continue;\n    currentnode.isVisited = true;\n    visitedNodesInOrder.push(currentnode);\n    if (currentnode === finishnode) {\n      return visitedNodesInOrder;\n    }\n    const {\n      row,\n      col\n    } = currentnode;\n    if (row < grid.length - 1 && grid[row + 1][col].isVisited === false) {\n      queue.push(grid[row + 1][col]);\n      grid[row + 1][col].previousNode = currentnode;\n    }\n    if (row > 0 && grid[row - 1][col].isVisited === false) {\n      queue.push(grid[row - 1][col]);\n      grid[row - 1][col].previousNode = currentnode;\n    }\n    if (col > 0 && grid[row][col - 1].isVisited === false) {\n      queue.push(grid[row][col - 1]);\n      grid[row][col - 1].previousNode = currentnode;\n    }\n    if (col < grid[0].length - 1 && grid[row][col + 1].isVisited === false) {\n      queue.push(grid[row][col + 1]);\n      grid[row][col + 1].previousNode = currentnode;\n    }\n  }\n  return visitedNodesInOrder;\n}\n//the below function finds the shortest path by connecting the previous nodes which were found during the graph traversal algorithm\nexport function getNodesInShortestPathOrderBFS(finishnode) {\n  const nodesInShortestPathOrder = [];\n  let current = finishnode;\n  while (current != null) {\n    nodesInShortestPathOrder.unshift(current);\n    //console.log(current);\n    current = current.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["bfs","grid","startnode","finishnode","visitedNodesInOrder","queue","push","console","log","length","currentnode","shift","wall","isVisited","row","col","previousNode","getNodesInShortestPathOrderBFS","nodesInShortestPathOrder","current","unshift"],"sources":["C:/Users/deepa/my-app/src/algorithms/bfs.js"],"sourcesContent":["export function bfs(grid,startnode,finishnode) {\r\n    const visitedNodesInOrder = [];\r\n    const queue = [];\r\n\r\n    queue.push(startnode);\r\n    \r\n    console.log(\"inside the bfs function\");\r\n    while(queue.length!==0){\r\n        \r\n        const currentnode = queue.shift();\r\n        if (currentnode.wall) continue;\r\n        if (currentnode.isVisited === true) continue;\r\n         \r\n\r\n        currentnode.isVisited = true;\r\n        visitedNodesInOrder.push(currentnode);\r\n        if(currentnode === finishnode) {\r\n            return visitedNodesInOrder;\r\n        }\r\n        \r\n        const {row, col} = currentnode;\r\n        \r\n        if (row < grid.length - 1 && grid[row+1][col].isVisited===false) {\r\n            queue.push(grid[row + 1][col]);\r\n            grid[row+1][col].previousNode = currentnode;\r\n        }\r\n        if (row > 0 &&  grid[row-1][col].isVisited===false) {\r\n            queue.push(grid[row-1][col]);\r\n            grid[row-1][col].previousNode = currentnode;\r\n        }\r\n        if (col > 0 && grid[row][col-1].isVisited===false) {\r\n            queue.push(grid[row][col-1]);\r\n            grid[row][col-1].previousNode = currentnode;\r\n        }\r\n        if (col < grid[0].length - 1 && grid[row][col+1].isVisited===false) {\r\n            queue.push(grid[row][col+1]);\r\n            grid[row][col+1].previousNode = currentnode;\r\n        }\r\n    }\r\n \r\n    return visitedNodesInOrder;\r\n\r\n}\r\n//the below function finds the shortest path by connecting the previous nodes which were found during the graph traversal algorithm\r\nexport function getNodesInShortestPathOrderBFS(finishnode){\r\n    const nodesInShortestPathOrder = [];\r\n    let current = finishnode;\r\n    while(current != null){\r\n        nodesInShortestPathOrder.unshift(current);\r\n        //console.log(current);\r\n      current = current.previousNode;\r\n      \r\n    }\r\n    return nodesInShortestPathOrder;\r\n}"],"mappings":"AAAA,OAAO,SAASA,GAAGA,CAACC,IAAI,EAACC,SAAS,EAACC,UAAU,EAAE;EAC3C,MAAMC,mBAAmB,GAAG,EAAE;EAC9B,MAAMC,KAAK,GAAG,EAAE;EAEhBA,KAAK,CAACC,IAAI,CAACJ,SAAS,CAAC;EAErBK,OAAO,CAACC,GAAG,CAAC,yBAAyB,CAAC;EACtC,OAAMH,KAAK,CAACI,MAAM,KAAG,CAAC,EAAC;IAEnB,MAAMC,WAAW,GAAGL,KAAK,CAACM,KAAK,CAAC,CAAC;IACjC,IAAID,WAAW,CAACE,IAAI,EAAE;IACtB,IAAIF,WAAW,CAACG,SAAS,KAAK,IAAI,EAAE;IAGpCH,WAAW,CAACG,SAAS,GAAG,IAAI;IAC5BT,mBAAmB,CAACE,IAAI,CAACI,WAAW,CAAC;IACrC,IAAGA,WAAW,KAAKP,UAAU,EAAE;MAC3B,OAAOC,mBAAmB;IAC9B;IAEA,MAAM;MAACU,GAAG;MAAEC;IAAG,CAAC,GAAGL,WAAW;IAE9B,IAAII,GAAG,GAAGb,IAAI,CAACQ,MAAM,GAAG,CAAC,IAAIR,IAAI,CAACa,GAAG,GAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAACF,SAAS,KAAG,KAAK,EAAE;MAC7DR,KAAK,CAACC,IAAI,CAACL,IAAI,CAACa,GAAG,GAAG,CAAC,CAAC,CAACC,GAAG,CAAC,CAAC;MAC9Bd,IAAI,CAACa,GAAG,GAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAACC,YAAY,GAAGN,WAAW;IAC/C;IACA,IAAII,GAAG,GAAG,CAAC,IAAKb,IAAI,CAACa,GAAG,GAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAACF,SAAS,KAAG,KAAK,EAAE;MAChDR,KAAK,CAACC,IAAI,CAACL,IAAI,CAACa,GAAG,GAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAAC;MAC5Bd,IAAI,CAACa,GAAG,GAAC,CAAC,CAAC,CAACC,GAAG,CAAC,CAACC,YAAY,GAAGN,WAAW;IAC/C;IACA,IAAIK,GAAG,GAAG,CAAC,IAAId,IAAI,CAACa,GAAG,CAAC,CAACC,GAAG,GAAC,CAAC,CAAC,CAACF,SAAS,KAAG,KAAK,EAAE;MAC/CR,KAAK,CAACC,IAAI,CAACL,IAAI,CAACa,GAAG,CAAC,CAACC,GAAG,GAAC,CAAC,CAAC,CAAC;MAC5Bd,IAAI,CAACa,GAAG,CAAC,CAACC,GAAG,GAAC,CAAC,CAAC,CAACC,YAAY,GAAGN,WAAW;IAC/C;IACA,IAAIK,GAAG,GAAGd,IAAI,CAAC,CAAC,CAAC,CAACQ,MAAM,GAAG,CAAC,IAAIR,IAAI,CAACa,GAAG,CAAC,CAACC,GAAG,GAAC,CAAC,CAAC,CAACF,SAAS,KAAG,KAAK,EAAE;MAChER,KAAK,CAACC,IAAI,CAACL,IAAI,CAACa,GAAG,CAAC,CAACC,GAAG,GAAC,CAAC,CAAC,CAAC;MAC5Bd,IAAI,CAACa,GAAG,CAAC,CAACC,GAAG,GAAC,CAAC,CAAC,CAACC,YAAY,GAAGN,WAAW;IAC/C;EACJ;EAEA,OAAON,mBAAmB;AAE9B;AACA;AACA,OAAO,SAASa,8BAA8BA,CAACd,UAAU,EAAC;EACtD,MAAMe,wBAAwB,GAAG,EAAE;EACnC,IAAIC,OAAO,GAAGhB,UAAU;EACxB,OAAMgB,OAAO,IAAI,IAAI,EAAC;IAClBD,wBAAwB,CAACE,OAAO,CAACD,OAAO,CAAC;IACzC;IACFA,OAAO,GAAGA,OAAO,CAACH,YAAY;EAEhC;EACA,OAAOE,wBAAwB;AACnC"},"metadata":{},"sourceType":"module","externalDependencies":[]}