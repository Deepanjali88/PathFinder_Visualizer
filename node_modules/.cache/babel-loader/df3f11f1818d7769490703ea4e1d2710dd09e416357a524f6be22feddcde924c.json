{"ast":null,"code":"class Stack {\n  // Array is used to implement stack \n  constructor() {\n    this.items = [];\n  }\n\n  // Functions to be implemented \n  // push(item) \n  push(element) {\n    this.items.push(element);\n  }\n  // pop() \n  pop() {\n    if (this.items.length === 0) return \"Underflow\";\n    return this.items.pop();\n  }\n  // peek()\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n  // isEmpty() \n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\nexport function dfs(grid, startnode, finishnode) {\n  const visitedNodesInOrder = [];\n  var stack = new Stack();\n  stack.push(startnode);\n  while (!stack.isEmpty()) {\n    var currentnode = stack.pop();\n    if (currentnode.isVisited === true || currentnode.wall === true) continue;\n    currentnode.isVisited = true;\n    visitedNodesInOrder.push(currentnode);\n    if (currentnode === finishnode) {\n      return visitedNodesInOrder;\n    }\n    const {\n      row,\n      col\n    } = currentnode;\n    if (row < grid.length - 1 && grid[row + 1][col].isVisited === false) {\n      stack.push(grid[row + 1][col]);\n      grid[row + 1][col].previousNode = currentnode;\n    }\n    if (row > 0 && grid[row - 1][col].isVisited === false) {\n      stack.push(grid[row - 1][col]);\n      grid[row - 1][col].previousNode = currentnode;\n    }\n    if (col > 0 && grid[row][col - 1].isVisited === false) {\n      stack.push(grid[row][col - 1]);\n      grid[row][col - 1].previousNode = currentnode;\n    }\n    if (col < grid[0].length - 1 && grid[row][col + 1].isVisited === false) {\n      stack.push(grid[row][col + 1]);\n      grid[row][col + 1].previousNode = currentnode;\n    }\n  }\n  return visitedNodesInOrder;\n}\n//the below function finds the shortest path by connecting the previous nodes which were found during the graph traversal algorithm\nexport function getNodesInShortestPathOrderDFS(finishnode, startnode) {\n  const nodesInShortestPathOrder = [];\n  let current = finishnode;\n  while (current != null) {\n    nodesInShortestPathOrder.unshift(current);\n    //console.log(current);\n    current = current.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"names":["Stack","constructor","items","push","element","pop","length","peek","isEmpty","dfs","grid","startnode","finishnode","visitedNodesInOrder","stack","currentnode","isVisited","wall","row","col","previousNode","getNodesInShortestPathOrderDFS","nodesInShortestPathOrder","current","unshift"],"sources":["C:/Users/deepa/my-app/src/algorithms/dfs.js"],"sourcesContent":["class Stack { \r\n  \r\n    // Array is used to implement stack \r\n    constructor() \r\n    { \r\n        this.items = []; \r\n    } \r\n  \r\n    // Functions to be implemented \r\n    // push(item) \r\n    push(element) \r\n    { \r\n    this.items.push(element); \r\n    } \r\n    // pop() \r\n    pop() \r\n    { \r\n        if (this.items.length === 0) \r\n            return \"Underflow\"; \r\n        return this.items.pop(); \r\n    }\r\n    // peek()\r\n    peek() \r\n    { \r\n        return this.items[this.items.length - 1]; \r\n    } \r\n    // isEmpty() \r\n    isEmpty() \r\n    { \r\n    return this.items.length === 0; \r\n    }\r\n    \r\n} \r\nexport function dfs(grid,startnode,finishnode){\r\n    const visitedNodesInOrder = [];\r\n\r\n    var stack = new Stack();\r\n    stack.push(startnode);\r\n\r\n    while( !stack.isEmpty()){\r\n         var currentnode = stack.pop();\r\n         if(currentnode.isVisited === true || currentnode.wall === true) continue;\r\n\r\n         currentnode.isVisited = true;\r\n         visitedNodesInOrder.push(currentnode);\r\n         \r\n         if(currentnode === finishnode) {\r\n             return visitedNodesInOrder;\r\n        }\r\n         const {row, col} = currentnode;\r\n        \r\n        if (row < grid.length - 1 && grid[row+1][col].isVisited===false) {\r\n            stack.push(grid[row + 1][col]);\r\n            grid[row+1][col].previousNode = currentnode;\r\n        }\r\n        if (row > 0 &&  grid[row-1][col].isVisited===false) {\r\n            stack.push(grid[row-1][col]);\r\n            grid[row-1][col].previousNode = currentnode;\r\n        }\r\n        if (col > 0 && grid[row][col-1].isVisited===false) {\r\n            stack.push(grid[row][col-1]);\r\n            grid[row][col-1].previousNode = currentnode;\r\n        }\r\n        if (col < grid[0].length - 1 && grid[row][col+1].isVisited===false) {\r\n            stack.push(grid[row][col+1]);\r\n            grid[row][col+1].previousNode = currentnode;\r\n        }\r\n    } \r\n    return visitedNodesInOrder;\r\n}\r\n//the below function finds the shortest path by connecting the previous nodes which were found during the graph traversal algorithm\r\nexport function getNodesInShortestPathOrderDFS(finishnode,startnode){\r\n    const nodesInShortestPathOrder = [];\r\n    let current = finishnode;\r\n    while(current != null){\r\n        \r\n        nodesInShortestPathOrder.unshift(current);\r\n        //console.log(current);\r\n      current = current.previousNode;\r\n      \r\n    }\r\n    return nodesInShortestPathOrder;\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}